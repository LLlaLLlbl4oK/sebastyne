#pragma config(Sensor, S1,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     ,               sensorEV3_Color)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int sil_new1 = 250;
int sil_new2 = 250;
int sil_1, sil_2;
int sil_old1 = 125;
int sil_old2 = 250;
//int mas[10];
int len = 0;
int a = 0;
float hh;
float white1, white2, black1, black2;
float S1N;
float S2N;
float S1N_R, S2N_R;
int r1, g1, b1;
int r2, g2, b2;
int r3, g3, b3;
//int r1c, g1c, b1c;
//int r2c, g2c, b2c;
//float sereb;
bool green1 = false;
bool green2 = false;
bool green3 = false;
int err, u ,errOld = 0, pReg, dReg;
float kP = 0.2;
float kp;
float kD = 14;
float kc = 0.00014;
int v = 20;
int raz = 0;
int c = 15;
float sens3;
bool flag = false;
bool silver1 = false;
bool silver2 = false;
bool red1 = false;
bool red2 = false;
bool red3 = false;
int e, ul;
float l = 2;
float k = 27;
int x, y;
int left;
int right;
int back, down;
int ball_l, ball_f, ball_r;



void tube()
{
	motor[motorA] = 100;
	sleep(300);
	motor[motorA] = 0;
	sleep(300);
	motor[motorA] = -10;
	sleep(1500);
	motor[motorA] = 10;
	sleep(300);
	motor[motorA] = 0;
	sleep(300);
	playSound(soundBlip);
}

void Line()
{
	errOld = err;
	err = S1N - S2N;
	u = err * kP + (err - errOld) * kD + err*err*err*kc;
	motor[motorB] = v + u;
	motor[motorC] = v - u;
	sleep(1);
}

void GreenRightTurn()
{
	nMotorEncoder[motorB] = 0;
	motor[motorB] = motor[motorC] = 30;
	while(nMotorEncoder[motorB] < 30)
		sleep(1);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 40;
	motor[motorC] = -40;
	while(nMotorEncoder[motorB] < 10)
		sleep(1);
	motor[motorB] = motor[motorC] = 0;
	sleep(500);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 40;
	motor[motorC] = -40;
	while(S2N > 30)
		sleep(1);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 30;
	motor[motorC] = -30;
	while(nMotorEncoder[motorB] < 50)
		sleep(1);

	repeat(800)
	{
		kP = 0.4;
		Line();
	}
	kP = kp;
}

void GreenNazadTurn()
{
	setSoundVolume(100);
	playSound(soundBeepBeep);
	sleep(500);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = motor[motorC] = -30;
	while(nMotorEncoder[motorB] > -70)
		sleep(1);
	motor[motorB] = motor[motorC] = 0;
	sleep(300);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 10;
	motor[motorC] = -10;
	while(nMotorEncoder[motorB] < 280)
		sleep(1);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 10;
	motor[motorC] = -10;
	while(S2N > 10)
		sleep(1);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 10;
	motor[motorC] = -10;
	while(nMotorEncoder[motorB] < 50)
		sleep(1);

	repeat(500)
	{
		Line();
	}
}

void Stenka()
{
	if(r3 > g3)
		sens3 = r3;
	else
		sens3 = g3;
	e = sens3 - l;
	ul = e * k;
	motor[motorB] = 100 - ul;
	motor[motorC] = 100 + ul;
	sleep(1);
}

void SOS()
{
	if(silver1 == true && silver2 == true)
	{
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 50)
			sleep(1);
		motor[motorB] = motor[motorC] = 10;
		sleep(500);
		motor[motorB] = motor[motorC] = 0;
		sleep(500);
		if(SensorValue[S3] <= 1)
		{
			nMotorEncoder[motorB] = 0;
			motor[motorB] = -30;
			motor[motorC] = 30;
			while(S1N > 50)
				sleep(1);
		}
		else
		{
			nMotorEncoder[motorB] = 0;
			motor[motorB] = -30;
			motor[motorC] = 30;
			while(nMotorEncoder[motorB] > -50)
				sleep(1);
			motor[motorB] = motor[motorC] = 30;
			sleep(800);
			motor[motorB] = 40;
			motor[motorC] = 10;
			while(SensorValue[S3] < 4)
				sleep(1);
			motor[motorB] = 0;
			motor[motorC] = 0;
			sleep(500);
			playSound(soundException);
			sleep(200);
			while(raz < 3)
			{
				if(SensorValue[S4] == 1 && SensorValue[S3] > 5)
				{
					motor[motorB] = motor[motorC] = -30;
					sleep(1000);
					motor[motorB] = 5;
					motor[motorC] = 30;
					sleep(1000);
				}
				if(green3 == true)
				{
					l = 1;
					//	repeat(400)
					//	{
					//		Stenka();
					//	}
					//	motor[motorB] = motor[motorC] = 0;
					//	sleep(500);

					//	nMotorEncoder[motorD] = 0;
					//	motor[motorD] = 70;
					//	while(nMotorEncoder[motorD] < 80)
					//		sleep(1);
					//	motor[motorD] = 0;
					//	sleep(400);
					//	nMotorEncoder[motorD] = 0;
					//	motor[motorD] = -70;
					//	while(nMotorEncoder[motorD] > -80)
					//		sleep(1);
					//	motor[motorD] = 0;
					//	sleep(300);
					//	repeat(2000);
					//	{
					//		Stenka();
					//	}
				}
				l = 3;
				if(SensorValue[S4] == 1)
				{
					motor[motorB] = motor[motorC] = 30;
					sleep(300);
					motor[motorB] = motor[motorC] = 20;
					sleep(300);
					motor[motorB] = 10;
					motor[motorC] = 10;
					sleep(300);
					motor[motorB] = motor[motorC] = 0;
					sleep(500);
					tube();
					tube();
					repeat(300)
					{
						Stenka();
					}
				}
				if(S1N < 10 && S2N < 10)
				{
					raz = raz + 3;
					if(raz < 3)
					{
						motor[motorB] = motor[motorC] = -30;
						sleep(2100);
						motor[motorB] = 5;
						motor[motorC] = 30;
						sleep(1700);
					}
					else
					{
						motor[motorB] = motor[motorC] = 30;
						sleep(300);
						motor[motorB] = 10;
						motor[motorC] = 30;
						while(S1N > 30)
							sleep(1);
						repeat(500)
						{
							Line();
						}
						motor[motorB] = 0;
						motor[motorC] = 0;
						sleep(500);
						setSoundVolume(100);
						playSound(soundException);
						sleep(200);
					}
				}


				//if(silver1 == true && silver2 == true)
				//{
				//	motor[motorB] = motor[motorC] = -30;
				//	sleep(2100);
				//	motor[motorB] = 5;
				//	motor[motorC] = 30;
				//	sleep(1700);
				//}
				Stenka();

			}
		}
	}
}




void GreenLeftTurn()
{
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 30;
	motor[motorC] = 30;
	while(nMotorEncoder[motorB] < 40)
		sleep(1);
	nMotorEncoder[motorC] = 0;
	motor[motorB] = -30;
	motor[motorC] = 30;
	while(nMotorEncoder[motorC] < 10)
		sleep(1);
	motor[motorB] = motor[motorC] = 0;
	sleep(500);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = -40;
	motor[motorC] = 40;
	while(S1N > 30)
		sleep(1);
	nMotorEncoder[motorC] = 0;
	motor[motorB] = -30;
	motor[motorC] = 30;
	while(nMotorEncoder[motorC] < 50)
		sleep(1);

	repeat(800)
	{
		kP = 0.4;
		Line();
	}
	kP = kp;
}

void Open()
{
	hh = fileOpenRead("parameters.dat");
	fileReadFloat(hh, &white1);
	fileReadFloat(hh, &black1);
	fileReadFloat(hh, &white2);
	fileReadFloat(hh, &black2);
	fileClose(hh);
}

task Color()
{
	setSoundVolume(1);
	while(true)
	{
		getColorRawRGB(S1, r1, g1, b1);
		getColorRawRGB(S2, r2, g2, b2);
		getColorRawRGB(S3, r3, g3, b3);
		if(g1 > r1*2 && g1 > b1 && g1 > 70 && b1 > 40)
		{
			green1 = true;
		}
		else
		{
			green1 = false;
		}

		if(g2 > r2*2 && g2 > b2 && g2 > 135 && b2 > 35)
		{
			green2 = true;
		}
		else
		{
			green2 = false;
		}

		if(g3 > r3*2 && g3 > b3 && g3 > 10)
		{
			green3 = true;
			playSound(soundBlip);
		}
		else
		{
			green3 = false;
		}



		if(r1 > g1*2 && r1 > b1*2 && r1 > 55 && b1 > 15)
		{
			red1 = true;
			playSound(soundBlip);
		}
		else
		{
			red1 = false;
		}

		if(r2 > g2*2 && r2 > b2*2 && g2 > 125 && b2 > 10)
		{
			red2= true;
			playSound(soundBlip);
		}
		else
		{
			red2 = false;
		}
		if(r3 > g3*2 && r3 > b3*2 && r3 > 70)
		{
			red3= true;
			playSound(soundBlip);
		}
		else
		{
			red3 = false;
		}




		S1N = 100 * (g1 - black1)/(white1 - black1);
		S2N = 100 * (g2 - black2)/(white2 - black2);

		if(S1N > sil_1)
		{
			silver1 = true;
		}
		else
		{
			silver1 = false;
		}
		if(S2N > sil_2)
		{
			silver2 = true;
		}
		else
		{
			silver2 = false;
		}

		if(S1N<4 && S2N<1)
		{

			clearTimer(T1);
		}

		displayTextLine(0,"rgb1: %d %d %d", r1, g1, b1);
		displayTextLine(1,"rgb2: %d %d %d", r2, g2, b2);
		displayTextLine(2,"rgb3: %d %d %d", r3, g3, b3);
		displayTextLine(3,"black: %d %d",black1, black2);
		displayTextLine(4,"white: %d %d",white1, white2);
		displayTextLine(5,"norm: %d %d", S1N, S2N);
		displayTextLine(6,"green: %d %d", green1, green2);
		displayTextLine(7,"silver: %d %d", silver1, silver2);
		sleep(10);

	}
}


void brick_left_big()
{
	if(SensorValue[S4] == 1)
	{
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = -30;
		while(nMotorEncoder[motorB] > -80)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30;
		motor[motorC] = 30;
		while(nMotorEncoder[motorB] > -190)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 260)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 190)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 530)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 210)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(S2N > 30)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 70)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30;
		motor[motorC] = 30;
		while(S1N > 30)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30;
		motor[motorC] = 30;
		while(nMotorEncoder[motorB] > -50)
			sleep(1);
		motor[motorB] = motor[motorC] = 0;
		sleep(500);
	}
}



void brick_right_big()
{
	if(SensorValue[S4] == 1)
	{
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = -30;
		while(nMotorEncoder[motorB] > -80)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30
		while(nMotorEncoder[motorB] <170)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] <260)//obezd
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30
		motor[motorC] = 30;
		while(nMotorEncoder[motorB] >-160)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] <550)//vdol
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30
		motor[motorC] = 30;
		while(nMotorEncoder[motorB] > -160)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(S2N > 30)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 50)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(S2N > 30)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 50)
			sleep(1);
		motor[motorB] = motor[motorC] = 0;
		sleep(500);
	}
}


void brick_left_small()
{
	if(SensorValue[S4] == 1)
	{
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = -30;
		while(nMotorEncoder[motorB] > -80)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30;
		motor[motorC] = 30;
		while(nMotorEncoder[motorB] > -190)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 240)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 170)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 610)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 175)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(S2N > 30)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 50)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30;
		motor[motorC] = 30;
		while(S1N > 30)
			sleep(1);
		motor[motorB] = motor[motorC] = 0;
		sleep(500);
	}
}



void brick_right_small()
{
	if(SensorValue[S4] == 1)
	{
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = -30;
		while(nMotorEncoder[motorB] > -80)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 180)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 250)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30;
		motor[motorC] = 30;
		while(nMotorEncoder[motorB] > -165)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 610)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = -30;
		motor[motorC] = 30;
		while(nMotorEncoder[motorB] > -180)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(S2N > 30)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorC] = motor[motorB] = 30;
		while(nMotorEncoder[motorB] < 50)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(S2N > 30)
			sleep(1);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = -30;
		while(nMotorEncoder[motorB] < 50)
			sleep(1);
		motor[motorB] = motor[motorC] = 0;
		sleep(500);
	}
}



task main()
{
	kp = kP;
	sil_1 = sil_old1;
	sil_2 = sil_old2;
	motor[motorA] = -10;
	sleep(1000);
	motor[motorA] = 0;
	Open();
	startTask(Color);
	sleep(500);
	while(x < 1)
	{
		if(getButtonPress(buttonLeft)==1)
		{
			left = 1;
			x = 1;
		}
		else
		{
			left = 0;
			x = 0;
			if(getButtonPress(buttonRight)==1)
			{
				right = 1;
				x = 1;
			}
			else
			{
				right = 0;
				x = 0;
			}
		}
	}
	playSound(soundBeepBeep);
	sleep(500);



	while(x < 2)
	{
		if(getButtonPress(buttonUp)==1)
		{
			back = 1;
			x = 2;
			playSound(soundBeepBeep);
			sleep(500);
		}
		else
		{
			back = 0;
			x = 0;
			if(getButtonPress(buttonDown)==1)
			{
				down = 1;
				x = 2;
			}
			else
			{
				down = 0;
				x = 0;
			}
		}
	}


	while(red1 < 1 && red2 < 1)
	{
		while(S1N >= 1000 && S2N >= 20)
		{
			repeat(30)
			{
				Line();
			}
		}
		SOS();
		if(right == 1)
		{
			if(back == 1)
			{
				brick_right_big();
			}
			else
			{
				brick_right_small();
			}
		}
		else
		{
			if(back == 1)
			{
				brick_left_big();
			}
			else
			{
			brick_left_small():
			}
		}
		if(S1N > 83 && S2N > 83)
		{
			kP = 0.43;
			kD = 26;
			kc = 0.00038;
			v = 30;
		}
		else
		{
			kP = 0.27;
			kD = 14;
			kc = 0.00017;
			v = 20;
		}
		if(S1N < 10)
		{
			flag = false;
			repeat(150)
			{
				Line();
				if(green1 == true)
					flag = true;

			}
			if(flag == true)
			{
				motor[motorB] = 40;
				motor[motorC] = 5;
				while(S1N > 10)
					sleep(1);
				repeat(300)
				{
					Line();
				}
			}
		}
		Line();
		if(time1[T1]>1500)
		{
			if(green1 == true)
			{
				flag = false;
				repeat(150)
				{
					motor[motorB] = motor[motorC] = 20;
					sleep(1);
					if(green2 == true)
						flag = true;
				}
				if(flag == true)
					GreenNazadTurn();
				else
					GreenLeftTurn();
			}
			if(green2 == true)
			{
				flag = false;
				repeat(150)
				{
					motor[motorB] = motor[motorC] = 20;
					sleep(1);
					if(green1 == true)
						flag = true;
				}
				if(flag == true)
					GreenNazadTurn();
				else
					GreenRightTurn();
			}
		}
	}
}
